require(raster)
require(matrixStats)

fn <- "input.csv" ### this is a csv file that needs the locality in the first column, in this case a 1x1 decimal degree raster grid cell, and the tiplabels belonging to this entitiy
coordinates <- read.csv("coordinates_localities.csv") ### File that specifies the locality of the raster grid cell using "Lon" & "Lat" as header

names <- c(1:20) #enter max n of elements per loc
as.character(names) -> names

df_w_OG <- read.csv(fn, header = FALSE, sep = ",", row.names = 1, na.strings=c("","NA"), col.names = names, stringsAsFactors = FALSE)
df <- subset(df_w_OG,row.names(df_w_OG) != "Outgroup") ### enter name of Outgroup as defined in input file; this tiplabels will be used as taxset that will be compared in PD complementarity calculation;


sample <- apply(df[1:nrow(df),], 1, function(x){sample(x[!is.na(x)], size = 1)}) ### enter size of subsample (in this case 1)
df_result <- cbind(sample)
df_result <- as.data.frame(df_result) 

for(i in 1:1000){
  apply(df[1:nrow(df),], 1, function(x){sample(x[!is.na(x)], size = 1)}) -> sample
  cbind(sample, df_result) -> df_result
}

df_result -> df_for_export
paste("taxset ",row.names(df_result), " = ",sep = "") -> row_names_f_export

row.names(df_for_export) <- row_names_f_export

header_nexus <- paste("#NEXUS")
begin_sets <- paste("begin sets;")
outgroup <- paste("taxset Outgroup = Tiplabel_51_1 Tiplabel_51_2 Tiplabel_51_3 Tiplabel_52_1 Tiplabel_52_2 Tiplabel_96_1 Tiplabel_96_2 Tiplabel_96_3 Tiplabel_94_1 Tiplabel_94_2 Tiplabel_94_3 Tiplabel_34_1 Tiplabel_34_2 Tiplabel_34_3 Tiplabel_85_1 Tiplabel_85_2 Tiplabel_68_1 Tiplabel_68_2;")  
###copy-paste outgroup tiplabels, don't forget ";" at the end.
end_sets <- paste("end; [sets]")

system("mkdir tempdir")
setwd("./tempdir")

for(i in sample(1:1000,size = 100)){ ###adapt number of replicates for subsampling
  temporal <- capture.output(cat(header_nexus, begin_sets, paste(row.names(df_for_export), df_for_export[,i],";",sep = ""), outgroup, end_sets, sep = "\n"))
  write(temporal, file = paste("area.nexus",i,sep="_"))
}

system("cp ../input.tree.nex ./")
system("sh ../exec_pda.sh") ### EDIT: enter path to pda in shell script; for info on pda software: O. Chernomor, B.Q. Minh, F. Forest, S. Klaere, T. Ingram, M. Henzinger, and A. von Haeseler (2015) Split diversity in constrained conservation prioritization using integer linear programming. Methods Ecol. Evol., 6, 83-91. DOI: 10.1111/2041-210X.12299
system("sh ../extract_PD_compl_results.sh") ### EDIT: adapt rownumbers in shell script according to the rows that contain PD complementarity values in *.out generated by pda files
###ignore "ls" "|" "grep" related errors

PD_compl_result_files <- list.files(pattern = "*.out.csv")

temp <- read.csv(sample(PD_compl_result_files, size = 1), header = FALSE, sep = " ", row.names = 2)
result_pda <- cbind(temp$V4)

for(i in PD_compl_result_files){
read.csv(i, header = FALSE, sep = " ", row.names = 2) -> x
  cbind(result_pda,x$V4) -> result_pda 
}

result_pda <- result_pda[,2:ncol(result_pda)] ### remove temp column
row.names(result_pda) <- row.names(temp)
setwd("../")

write.csv(result_pda, "summary.csv")

mean_result <- cbind(rowMeans(result_pda))
mean_result <- as.data.frame(mean_result)
mean_result_for_raster <- cbind(coordinates$Lon, coordinates$Lat, mean_result$V1)
colnames(mean_result_for_raster) <- c("x","y","z")

median_result <- cbind(rowMedians(result_pda))
median_result <- as.data.frame(median_result)
median_result_for_raster <- cbind(coordinates$Lon, coordinates$Lat, median_result$V1)
colnames(median_result_for_raster) <- c("x","y","z")

rasterFromXYZ(xyz = mean_result_for_raster, res = c(1,1)) -> mean_raster
writeRaster(x = mean_raster, filename = "downsampled_raster_mean.asc", overwrite = TRUE)

rasterFromXYZ(xyz = median_result_for_raster, res = c(1,1)) -> median_raster
writeRaster(x = median_raster, filename = "downsampled_raster_mean.asc", overwrite = TRUE)


####### OPTIONAL ######

### boxplot of variance

boxplot(t(result_pda), las = 2, ylab = "PD complementarity")


